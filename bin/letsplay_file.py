from bin.data_management import DM
from bin.constants import VERSION
from moviepy.video.io.VideoFileClip import VideoFileClip
from bin.minfuncs import getHexDoubleZeros
from bin.constants import LC,EC,DEFAULT_LPF_FILE
from bin.constants import PATHS
from os import listdir
from typing import Any
from pygame import key,K_LCTRL
from os.path import isfile
import hashlib
class TADImage: 
    """
    ThumbnailAutomationData Image Data
    -----
    Normally you don't need this class.
    
    Only `ThumbnailAutomationData` will create & manage instances of this class. 
    """
    def __init__(self,data: dict):
        self.data = data
        
    def asdict(self) -> dict:
        """
        Returns a dictionary representation of the object's key attributes.

        This method serializes the 'path', 'scale', 'pos', 'rot', 'align',
        and 'cropping' attributes into a dictionary format.

        Returns:
            dict: A dictionary containing the following keys and their
                corresponding attribute values:
                - 'path': The object's path.
                - 'scale': The object's scale.
                - 'pos': The object's position.
                - 'rot': The object's rotation.
                - 'align': The object's alignment.
                - 'cropping': The object's cropping information.
                
        Note: 
            generated by gemini, edited by justus decker
        """
        return {
            'path': self.path,
            'scale': self.scale,
            'pos': self.pos,
            'rot': self.rot,
            'align': self.align,
            'cropping': self.cropping
        }
    @property
    def path(self) -> str:
        return self.data['path'] # NO FAILSAVE: IF PATH NOT THERE LET THE USER KNOW!
    @path.setter
    def path(self,value: str):
        self.data['path'] = value
    @property
    def scale(self) -> float | int:
        return self.data.get('scale',1.)
    @scale.setter
    def scale(self,value: float | int):
        self.data['scale'] = value
    @property
    def pos(self) -> tuple[int,int]:
        return self.data.get('pos',(0,0))
    @pos.setter
    def pos(self,value: tuple[int,int]):
        self.data['pos'] = value
    @property
    def rot(self) -> float | int:
        return self.data.get('rot',0)
    @rot.setter
    def rot(self,value: float | int):
        self.data['rot'] = value
    @property
    def align(self) -> str:
        return self.data.get('align',"center")
    @align.setter
    def align(self,value: str):
        self.data['align'] = value
    @property
    def cropping(self) -> str:
        return self.data.get('cropping',[0,0,0,0])
    @cropping.setter
    def cropping(self,value: str):
        self.data['cropping'] = value
class ThumbnailAutomationData:
    def __init__(self, data: dict):
        self.data = data
        self.image_tad_instances: list[TADImage] = [TADImage(i) for i in self.data.get('images',[])]
    
    def asdict(self) -> dict:
        #! Some data is missing for random rotating images and stuff!
        return {
            'text': {
                'font': self.font,
                'align': self.text_align,
                'size': self.font_size,
                'pos': self.text_pos,
                'rot': self.text_rot,
                'cropping': self.text_cropping,
                'outline': self.text_outline
            },
            'images': [i.asdict() for i in self.image_tad_instances]
        }
    
    def get_image(self,index: int) -> TADImage:
        return self.image_tad_instances[index]
    
    @property
    def image_count(self) -> int:
        return len(self.image_tad_instances)
    @property
    def images(self) -> list[TADImage]:
        return self.image_tad_instances
    @property
    def __epnum(self) -> dict:
        return self.data.get('text_epNum',{}) #! Add a default value
    @property
    def text(self) -> str: # Currently unused
        return ""
    @property
    def font(self) -> str: # Currently unused
        return self.__epnum.get('font','C:\\Windows\\Fonts\\bahnschrift')
    @font.setter
    def font(self,value: str):
        self.__epnum['font'] = value
    @property
    def text_align(self) -> str:
        return self.__epnum.get('align','center')
    @text_align.setter
    def text_align(self,value: str):
        self.__epnum['align'] = value
    @property
    def font_size(self) -> int:
        return self.__epnum.get('size',100)
    @font_size.setter
    def font_size(self,value: int):
        self.__epnum['size'] = value
    @property
    def text_pos(self) -> tuple[int,int]:
        return self.__epnum.get('pos',(0,0))
    @text_pos.setter
    def text_pos(self,value: tuple[int,int]):
        self.__epnum['pos'] = value
    @property
    def text_rot(self) -> int:
        return self.__epnum.get('rot',0)
    @text_rot.setter
    def text_rot(self,value: str):
        self.__epnum['rot'] = value
    @property
    def text_cropping(self) -> int:
        return self.__epnum.get('cropping',[0,0,0,0])
    @text_cropping.setter
    def text_cropping(self,value: list[int]):
        self.__epnum['cropping'] = value
    @property
    def text_outline(self) -> int: # SETTER currently not implemented
        return self.__epnum.get('outline',{
                "xMinus": 2,
                "xPlus": 2,
                "yMinus": 2,
                "yPlus": 2,
                "color": [  [ 50, 50, 50 ],
                            [ 14, 14, 14 ],
                            [ 14, 14, 14 ],
                            [ 50, 50, 50 ]]
            })


class Episode:
    def __init__(self,data:dict) -> None:
        self.data = data
        
    def asdict(self) -> dict:
        return {
            'path': self.video_path,
            'episode_number': self.episode_number,
            'status': self.status,
            'markers': self.markers,
            'episode_title': self.title,
            'thumbnail_path': self.thumbnail_path,
            'thumbnail_frame': self.frame,
            'upload_at': self.upload_at,
            'audio_file_path': self.audio_path,
            'flags': None
        }
    @property
    def video_path(self) -> str:
        return self.data.get('path','')
    
    @video_path.setter
    def video_path(self, value: str):
        self.data['path'] = value
    @property
    def video_exist(self) -> str:
        return isfile(self.video_path)
    @property
    def audio_exist(self) -> str:
        return isfile(self.audio_path)
    @property
    def episode_number(self) -> int:
        return self.data.get('episode_number','')
    @episode_number.setter
    def episode_number(self, value: int):
        self.data['episode_number'] = value
    @property
    def status(self) -> int:
        return self.data.get('status','')
    @status.setter
    def status(self, value: int):
        self.data['status'] = value
    @property
    def markers(self) -> list[str]:
        return self.data.get('markers',[''])
    @markers.setter
    def markers(self, value: list[str]):
        self.data['markers'] = value
    @property
    def title(self) -> str:
        return self.data.get('episode_title','')
    @title.setter
    def title(self, value: str):
        self.data['episode_title'] = value
    @property
    def thumbnail_path(self) -> str:
        return self.data.get('thumbnail_path','')
    @thumbnail_path.setter
    def thumbnail_path(self, value: str):
        self.data['thumbnail_path'] = value
    @property
    def thumbnail_tmp(self) -> str:
        return '../style'
    @property
    def thumbnail_exist(self) -> str:
        return isfile(self.thumbnail_path)
    @property
    def frame(self) -> int | float:
        return self.data.get('thumbnail_frame','')
    @frame.setter
    def frame(self, value: int | float):
        self.data['thumbnail_frame'] = value
    @property
    def upload_at(self) -> str:
        return self.data.get('upload_at','')
    @upload_at.setter
    def upload_at(self, value: str):
        self.data['upload_at'] = value
    @property
    def audio_path(self) -> str:
        return self.data.get('audio_file_path','')
    @audio_path.setter
    def audio_path(self, value: str):
        self.data['audio_file_path'] = value
    @property
    def video_size(self) -> int:
        return self.data.get('video_file_size',-1)
    @video_size.setter
    def video_size(self, value: int):
        self.data['video_file_size'] = value
    @property
    def video_length(self) -> int:
        return self.data.get('video_length',-1)
    @video_length.setter
    def video_length(self, value: int):
        self.data['video_length'] = value
class LetsPlayFile:
    #Defaults
    default_ThumbnailAutomationData: dict = {
        "text_epNum": {
            "text": "",
            "font": "E:\\Server\\Programmierung\\JRI\\bin\\fonts\\Jersey.ttf",
            "align": "center",
            "size": 100,
            "pos": [
                800,
                260
            ],
            "rot": -15,
            "cropping": [
                0,
                0,
                0,
                0
            ],
            "outline": {
                "xMinus": 2,
                "xPlus": 2,
                "yMinus": 2,
                "yPlus": 2,
                "color": [  [ 50, 50, 50 ],
                            [ 14, 14, 14 ],
                            [ 14, 14, 14 ],
                            [ 50, 50, 50 ]]
            }
        },
        "images": [
            {
                "path": "logos\\7d2d_logo.png",
                "scale": 0.4,
                "pos": [
                    640,
                    140
                ],
                "rot": 0,
                "align": "center",
                "cropping": [
                    0,
                    0,
                    0,
                    0
                ]
            }
        ]
    }
    def __init__(self,filePath:str) -> None:
        self.filePath = filePath
        self.load()
        
    # In 1.14.77 get / set methods are mostly replaced by property & setter if possible
    # So the code will be much easier to maintain.
    def asdict(self) -> dict:
        return {
            'name': self.name,
            'episode_length': self.episode_length,
            'game_name': self.game_name,
            'title_ending': self.title_ending,
            'description': self.description,
            'tags': self.tags,
            'episodes': [i.asdict() for i in self.episodes],
            'tad': self.tad.asdict()
        }
    
    @property
    def hash(self) -> str:
        h = hashlib.new('SHA256')
        h.update(self.name.encode())
        return h.hexdigest()
    @property
    def episodes(self) -> list[Episode]:
        return [Episode(i) for i in self.data['episodes']]
    @property
    def episode_count(self) -> int:
        return len(self.episodes)
    @property
    def episode_length(self) -> int:
        return self.data.get('episode_length',1800)
    @episode_length.setter
    def episode_length(self,value: int):
        self.data['episode_length'] = value
    @property
    def game_name(self) -> str:
        return self.data.get('game_name','')
    @game_name.setter
    def game_name(self,value: str):
        self.data['game_name'] = value
    @property
    def title_ending(self) -> str:
        return self.data.get('title_ending','')
    @title_ending.setter
    def title_ending(self,value: str):
        self.data['title_ending'] = value
    @property
    def description(self) -> str:
        return self.data.get('description','')
    @description.setter
    def description(self,value: str):
        self.data['description'] = value
    @property
    def tags(self) -> list[str] | list:
        return self.data.get('tags',[])
    @tags.setter
    def tags(self,value: list[str]):
        self.data['tags'] = value
    @property
    def tad(self) -> ThumbnailAutomationData:
        return ThumbnailAutomationData(self.data.get('tad',{}))
    @property
    def icon_path(self) -> str:
        return self.data.get('icon',"")
    @icon_path.setter
    def icon_path(self,value: str):
        self.data['icon'] = value
    @property
    def name(self) -> str:
        return self.data.get('name',"")
    @name.setter
    def name(self,value: str):
        self.data['name'] = value
    @property
    def version(self) -> tuple:
        return self.data.get('version',VERSION)
    def add_episode(self,data:dict):
        """ Appends a new episode's data to the 'episodes' list. """
        self.data['episodes'].append(data) #! change this to get(set)
    def get_episode(self,index: int) -> Episode:
        return self.episodes[index]
    def get_episode_ex(self,index: int, key: str) -> Any:
        return self.get_episode(index)[key]
    def get_key_exist_in_episode(self,index: int, key: str):
        return key in self.get_episode(index)
    def set_episode(self,index: int, key: str, value: Any) -> None:
        self.episodes[index][key] = value
    def set_tad(self,attr: str, value: Any) -> None:
        self.tad.__setattr__(attr, value)
    def set_image_tad(self,index:int, attr: str, value: Any) -> None:
        self.tad.images[index].__setattr__(attr,value)


    
    def createBackUp(self):
        DM.create_folder(f'{PATHS.root}')
        DM.create_folder(f'{PATHS.letsplay}backups')
        fName,ending = self.filePath.split('\\')[-1].split('.')
        DM.save(f"{PATHS.letsplay}backups\\{fName}_backup.{ending}",self.data)
    def load(self):
        try:
            self.data: dict = DM.loads(self.filePath)
            self.createBackUp()
        except Exception as E:
            print(E)
            raise Exception("Something went wrong")
            #fName,ending = self.filePath.split('\\')[-1].split('.')
            
            #self.data: dict = DM.loads(f"data\\backups\\{fName}_backup.{ending}")
            #DM.save()
    def save(self):
        DM.save(self.filePath,self.data)
def get_ep_by_hash(lpf: list[LetsPlayFile],item: str) -> LetsPlayFile | None:

    _ret = None
    for lp in lpf:
        for ep in lp.episodes:


                
            if item == lp.hash:
                return ep
def get_lpf_by_hash(lpf: list[LetsPlayFile],item: str) -> LetsPlayFile | None:
    hashmap = set()
    _ret = None
    for lp in lpf:
        
        if lp in hashmap:
            raise NameError('Lets Play duplicate found!')
        else:
            hashmap.add(lp.hash)
            if item == lp.hash:
                _ret = lp
    return _ret



class LetsPlayComp:
    def __init__(self,fontPath,imgPath) -> None:

        self.imgPath = imgPath
        self.fontPath = fontPath
        self.start = 0
        self.load()
    
    def setTADInputs(self,l:list,cp,cs,lpf:list):
        self.dataTAD = l.copy()
        self.cpTAD = cp
        self.csTAD = cs
        self.dataLPF = lpf.copy()
        
    
    def change2Episode(self,side:int=0,callback:Any=None):
        """
            Change the current Episode
        """
        add = 0
        if key.get_pressed()[K_LCTRL]:
            add = 9
            
        
        if side == 1:
            self.start += (1 + add)
        else:
            self.start -= (1 + add)
            
        if self.start > len(self.episodesInQueue) - 1:
            self.start = len(self.episodesInQueue) - 1
        elif self.start < 0:
            self.start = 0
        if callback is not None:
            callback()
    
    def saveLetsPlays(self,*_): self.save()
    
    def load(self,*_):
        
        self.letsPlayFiles = []
        self.episodesInQueue = []

        DIR = listdir(PATHS.letsplay)
        DIR = [f for f in DIR if f.endswith('.json')]
        if DIR.__len__() == 0:
            return False #! Program crashed
        _deletableFiles = []
        for letsPlayIndex, filePath in enumerate(DIR):
            
            LPF = LetsPlayFile(PATHS.letsplay + filePath)
            self.letsPlayFiles.append(LPF)
            for episodeId in range(LPF.episode_count):
                if LPF.get_episode_ex(episodeId,'status') < 31: # TODO : Use the new ST values
                    self.episodesInQueue.append((letsPlayIndex,episodeId))
                else:
                    for p in [
                        LPF.get_episode_ex(episodeId,EC.ORIGINAL_AUDIO_PATH),
                        LPF.get_episode_ex(episodeId,EC.ORIGINAL_VIDEO_PATH),
                        LPF.get_episode_ex(episodeId,EC.THUMBNAIL_PATH),
                        f'{PATHS.audio}{LPF.name()}\\comps\\{episodeId+1}_comp.mp3'
                        ]:
                        if DM.existFile(p):
                            _deletableFiles.append(p)
                    LPF._setEpisode(episodeId,EC.STATUS,64)  # TODO : Use the new ST values
        _ = "\n".join(_deletableFiles)
        if len(_deletableFiles) > 0:
            pass
            #_answer = QuestionBox(['Unused Data Detected',f'Delete? {_}'])
            #if _answer == 6:
            #    self.deleteFiles(_deletableFiles)  
    def deleteFiles(self,_data):
        for f in _data:
            
            DM.removeFile(f)
                    
    def save(self):
        for letsPlayFile in self.letsPlayFiles:
            letsPlayFile.save()
            
    def getLPDataComp(self) -> dict:
        """
        Returns:
            dict: The Complete Lets Play File Data
        """
        return self.letsPlayFiles[self.episodesInQueue[self.start][0]].data
    
    def getIsLastEpisode(self) -> bool:
        """
        Returns:
            bool: Returns whether the current Episode is the last in the Lets Play File
        """
        return self.getEpisodeIndex() == self.getLPEpisodeAmmount() - 1
    
    def getLPIndex(self) -> int:
        """
        Returns:
            int: Current Index
        """
        return self.episodesInQueue[self.start][0]
    
    def setCuLp(self,key,value):
        self.letsPlayFiles[self.episodesInQueue[self.start][0]][key] = value
    
    def getCuLp(self,key):
        return self.getLPDataComp()[key]
    
    def getEpisodeIndex(self) -> int:
        return self.episodesInQueue[self.start][1]
    
    def getLPF(self) -> LetsPlayFile:
        return self.letsPlayFiles[self.getLPIndex()]
    
    def getLPEpisodeAmmount(self) -> int:
        return self.getLPF().episode_count
    
    def getCuEpKeyExist(self,key: str = '') -> bool: 
        return self.getLPF().get_key_exist_in_episode(self.getEpisodeIndex(),key)
    
    def getCuEpComp(self) -> dict:
        return self.getLPF().get_episode(self.getEpisodeIndex())
    
    def getCuEp(self,key: str = '') -> str | int | float | dict | list | bool:
        return self.getLPF().get_episode_ex(self.getEpisodeIndex(),key)
    
    def setCuEp(self,key: str = '',value: Any = None) -> None: 
        self.getLPF()._setEpisode(self.getEpisodeIndex(),key,value)

    def getThumbnailPath(self):
        return f'{PATHS.thumbnail}{self.getCuLp(LC.NAME)}\\{self.getCuEp(EC.EPISODE_NUMBER)}_{self.getCuLp(LC.NAME)}_Thumbnail.png'
    
    def getVideoPath(self):
        return self.getCuEp(EC.ORIGINAL_VIDEO_PATH)

    def getAudioPath(self):
        return self.getCuEp(EC.ORIGINAL_AUDIO_PATH)

    def getCompPathWOF(self):
        return f'{PATHS.audio}{self.getCuLp(LC.NAME)}\\comps\\'

    def getCompPath(self):
        return f'{PATHS.audio}{self.getCuLp(LC.NAME)}\\comps\\{self.getCuEp(EC.EPISODE_NUMBER)}_comp.mp3'
    
    def setTAD(self,data):
        self.getLPF().data[LC.THUMBNAIL_AUTOMATION_DATA] = data
    
    def getTAD(self):
        return self.getCuLp(LC.THUMBNAIL_AUTOMATION_DATA)
    
    def _setNewThumbnailAutomationData(self,*_):
        """
        self.jtgTextSizeInput
        """

        
        
        TAD = self.getTAD()
        _COPY = TAD.copy()
        
        bgExist = 'background' in TAD
        
        TE = TAD['text_epNum']
        IMG = TAD['images']
        
        if bgExist:
            BG = TAD['background']
        else:
            BG = {}
        
        TE['font'] = DM.ine(self.fontPath.path,TE['font'])
        TE['size'] = DM.ifane(self.dataTAD[0].text,TE['size'])
        TE['pos'] = DM.idane(self.dataTAD[1].text,TE['pos'][0]),DM.idane(self.dataTAD[2].text,TE['pos'][1])
        TE['rot'] = DM.ifane(self.dataTAD[3].text,TE['rot'])
        
        TAD['text_epNum'] = TE  #* Reapply Values
        
        IMG[0]['path'] = DM.ine(self.imgPath.path,IMG[0]['path'])
        IMG[0]['scale'] = DM.ifane(self.dataTAD[4].text,IMG[0]['scale'])
        IMG[0]['pos'] = DM.idane(self.dataTAD[5].text,IMG[0]['pos'][0]),DM.idane(self.dataTAD[6].text,IMG[0]['pos'][1])
        IMG[0]['rot'] = DM.ifane(self.dataTAD[7].text,IMG[0]['rot'])
        
        R = int(self.cpTAD.sliderR.sliderPercent * 255)
        G = int(self.cpTAD.sliderG.sliderPercent * 255)
        B = int(self.cpTAD.sliderB.sliderPercent * 255)
        
        R = getHexDoubleZeros(hex(R).replace('0x',''))
        G = getHexDoubleZeros(hex(G).replace('0x',''))
        B = getHexDoubleZeros(hex(B).replace('0x',''))
        
        TE['color'] = f'#{R}{G}{B}'
        
        TAD['images'] = IMG  #* Reapply Values
        
        #Weise Alle Werte zu
        if bgExist:
            BG['position'] = DM.idane(self.dataTAD[8].text,BG['position'][0]),DM.idane(self.dataTAD[9].text,BG['position'][1])
            
            BG['randomPositionX'] = DM.idane(self.dataTAD[10].text,BG['randomPositionX'])
            BG['randomPositionY'] = DM.idane(self.dataTAD[11].text,BG['randomPositionY'])
            
            BG['rotation'] = DM.ifane(self.dataTAD[12].text,BG['rotation'])
            
            BG['randomRotation'] = DM.ifane(self.dataTAD[13].text,BG['randomRotation'][0]),DM.ifane(self.dataTAD[14].text,BG['randomRotation'][1])
            BG['randomScale'] = DM.idane(self.dataTAD[15].text,BG['randomScale'][0]),DM.idane(self.dataTAD[16].text,BG['randomScale'][1])
            
            BG['scale'] = DM.ifane(self.dataTAD[17].text,BG['scale'])
            
            BG['hue'] = DM.ifane(self.dataTAD[18].text,BG['hue'])
            BG['saturation'] = DM.ifane(self.dataTAD[19].text,BG['saturation'])
            BG['lightness'] = DM.ifane(self.dataTAD[20].text,BG['lightness'])
            BG['center'] = self.csTAD.toggle
        
            TAD['background'] = BG  #* Reapply Values
        else:#!
            BG['position'] = DM.idane(self.dataTAD[8].text,0),DM.idane(self.dataTAD[9].text,0)
            
            BG['randomPositionX'] = DM.idane(self.dataTAD[10].text,0)
            BG['randomPositionY'] = DM.idane(self.dataTAD[11].text,0)
            
            BG['rotation'] = DM.ifane(self.dataTAD[12].text,0)
            
            BG['randomRotation'] = DM.ifane(self.dataTAD[13].text,0),DM.ifane(self.dataTAD[14].text,0)
            BG['randomScale'] = DM.idane(self.dataTAD[15].text,0),DM.idane(self.dataTAD[16].text,0)
            
            BG['scale'] = DM.ifane(self.dataTAD[17].text,1)
            
            BG['hue'] = DM.ifane(self.dataTAD[18].text,0)
            BG['saturation'] = DM.ifane(self.dataTAD[19].text,1)
            BG['lightness'] = DM.ifane(self.dataTAD[20].text,1)
            BG['center'] = self.csTAD.toggle
        
            TAD['background'] = BG  #* Reapply Values
        print(TAD['background'])
        self.setTAD(TAD)

    def getEssentialFolderCommands(self):
        _temp = self.getCuEp(EC.ORIGINAL_VIDEO_PATH).split('/')[0:-1]
        _path = ''
        for i in _temp:
            _path += i + '\\'
        return [
            f"explorer {self.getLPF().filePath}",
            f"explorer {PATHS.audio}{self.getCuLp(LC.NAME)}",
            f"explorer {_temp}",
            f"explorer {PATHS.thumbnail}{self.getCuLp(LC.NAME)}",
        ]
    
    def updateLetsPlaySettings(self,*_):
        if self.dataLPF[0].text != '':
            self.getLPF()._setName(self.dataLPF[0].text)
        if self.dataLPF[1].text != '':
            self.getLPF()._setIconPath(self.dataLPF[1].text)
    
        
    
    #change Lets Play
    
    #Getter & Setter
 
 
def createDefaultLPF(*_):
    DM.save(PATHS.letsplay + 'default.json',DEFAULT_LPF_FILE)